
# 语言规范手册.doc

## 1. 手册概述

### 1.1 目的

为保证本VM系统开发过程中，代码风格统一、可读性强、可维护性高，减少后期维护成本，避免因编码不规范导致的bug与逻辑混乱，制定本语言规范手册，所有开发工作必须严格遵循本规范。

### 1.2 适用范围

本规范适用于本VM系统的所有代码开发，包括VM核心模块（x86/arm/x64 VM）、调度器模块、内核终端模块、工具封装模块等，涵盖C++代码编写、注释、命名、工程化等所有环节。

### 1.3 核心原则

- 可读性优先：代码不仅要能运行，还要便于他人（或后期自己）阅读、理解、修改，避免晦涩难懂的写法。

- 一致性：命名、注释、代码格式保持统一，不出现多种风格。

- 简洁高效：代码简洁，避免冗余；底层代码优先保证效率，避免不必要的内存拷贝与冗余计算。

- 安全性：底层开发需注意内存安全，避免内存泄露、越界、空指针引用等问题；内核态代码需遵循最小权限原则，避免安全漏洞。

## 2. 开发语言规范（C++）

### 2.1 语言版本

统一使用C++11及以上版本，优先使用C++11特性（如智能指针、lambda表达式、范围for循环），避免使用C++17及以上的高阶特性（保证兼容性，降低开发门槛）；禁止混用C语言与C++语言的特性（如禁止用C的malloc/free，改用new/delete或智能指针）。

### 2.2 内存管理规范

- 智能指针优先：优先使用std::unique_ptr、std::shared_ptr管理内存，避免手动new/delete，减少内存泄露风险；内核态代码不支持智能指针时，需严格管理new/delete，确保成对出现。

- 禁止空指针：避免使用NULL，统一使用nullptr；使用指针前，必须进行空指针校验，防止空指针引用崩溃。

- 内存越界防护：使用数组、容器时，严格校验索引范围；禁止使用野指针，指针释放后，需置为nullptr。

- 零拷贝规范：VM模块读取payload时，严格遵循零拷贝机制，直接使用指针访问，禁止拷贝payload数据；其他模块如需共享数据，优先使用指针/引用，避免冗余拷贝。

### 2.3 数据类型规范

- 明确数据类型：禁止使用int、long等不确定长度的类型，统一使用固定长度类型（如uint8_t、uint32_t、int32_t，需包含<cstdint>头文件），确保跨平台兼容性。

- 避免魔法数字：将常用的常量（如时间片大小、核数上限、资源配额）定义为const或enum类型，命名规范，便于修改与理解。

- 结构体/类规范：结构体用于纯数据存储，不包含成员函数；类用于封装逻辑与数据，遵循封装原则，私有成员不可直接访问，通过公有接口操作。

### 2.4 并发编程规范

- 线程管理：使用std::thread或Boost.Thread管理线程，线程启动后，需确保正确join或detach，避免线程泄露；核绑定线程需调用CPU亲和性接口，确保线程运行在指定核上。

- 锁机制：核锁、线程同步优先使用std::atomic（无锁编程）、std::mutex，避免使用重量级锁；锁的持有时间尽量短，禁止嵌套锁（防止死锁）；使用std::lock_guard、std::unique_lock管理锁，确保自动释放。

- 避免竞态条件：多线程访问共享资源时，必须加锁保护；共享资源优先使用原子变量，减少锁的使用。

## 3. 命名规范

### 3.1 通用原则

命名必须清晰、准确，体现变量/函数/类的用途，禁止使用无意义的命名（如a、b、c、func1）；命名长度适中，避免过长或过短；禁止使用中文、拼音、缩写（通用缩写除外，如VM、CPU、EAX）。

### 3.2 变量命名

- 局部变量/成员变量：采用小驼峰命名法（lowerCamelCase），如vmId、cpuCore、contextData。

- 全局变量：采用大驼峰命名法（UpperCamelCase），前缀加g_，如g_vmQueue、g_coreLockMap（尽量减少全局变量的使用）。

- 常量/枚举：采用全大写命名法，单词间用下划线分隔，如TIME_SLICE_SIZE、CORE_MAX_LIMIT；枚举类型名采用大驼峰命名法，枚举值全大写。

- 指针变量：指针符号*紧贴变量名，如uint32_t* eaxValue，不写成uint32_t *eaxValue。

### 3.3 函数命名

- 普通函数：采用小驼峰命名法，动词开头，体现函数的操作，如startVm、saveContext、applyCore。

- 类成员函数：采用小驼峰命名法，与普通函数一致，如vmInterface->pause()、coreManager->releaseCore()。

- 内核态函数：前缀加k_，小驼峰命名法，如k_forceStopVm、k_recycleCore，区分用户态函数。

- 函数参数：小驼峰命名法，与局部变量一致，参数名清晰，避免使用单字母参数（如int a）。

### 3.4 类/结构体/接口命名

- 类：采用大驼峰命名法，名词开头，体现类的用途，如X86Vm、ArmVm、Scheduler、CoreManager。

- 结构体：采用大驼峰命名法，前缀加S_，如S_VmContext、S_CoreStatus，区分类与结构体。

- 接口：采用大驼峰命名法，前缀加I_，如I_VmInterface，明确接口身份，便于识别。

- 命名空间：采用全小写命名法，单词间用下划线分隔，如vm_system、core_manager，避免命名冲突。

### 3.5 文件命名

- 头文件：采用全小写命名法，单词间用下划线分隔，后缀为.h，如x86_vm.h、scheduler.h、vm_interface.h。

- 源文件：采用全小写命名法，单词间用下划线分隔，后缀为.cpp，与头文件同名，如x86_vm.cpp、scheduler.cpp。

- 内核态文件：前缀加k_，如k_admin_terminal.h、k_admin_terminal.cpp，区分用户态文件。

## 4. 注释规范

### 4.1 注释原则

注释要简洁、准确，体现代码的逻辑与用途，避免冗余注释（如// 定义变量a）；注释与代码同步更新，代码修改后，对应的注释必须修改；禁止使用中文注释，统一使用英文注释。

### 4.2 类/接口/结构体注释

类、接口、结构体定义前，必须添加块注释（/** ... */），说明其用途、核心功能、设计思路，必要时说明使用注意事项；结构体成员、类成员变量，添加行注释，说明其含义。

示例：

```cpp

/**
 * @brief VM统一抽象接口，屏蔽x86/arm/x64架构差异，供调度器调用
 * @details 所有架构VM必须实现该接口，包含生命周期、上下文、指令执行等核心功能
 * @note 接口方法不可随意修改，修改需同步所有架构VM的实现
 */
class I_VmInterface {
private:
    uint32_t vmId; // VM唯一标识，由调度器分配
    S_VmContext context; // VM运行上下文，包含寄存器、EIP、标志位等
public:
    virtual void start() = 0; // 启动VM，开始执行指令
    virtual void pause() = 0; // 暂停VM，保存当前上下文
};
    
```

### 4.3 函数注释

所有函数（尤其是公有函数、核心函数）定义前，必须添加块注释，说明函数用途、参数含义、返回值、异常情况，必要时说明调用注意事项。

示例：

```cpp

/**
 * @brief 申请静态独占核
 * @param vmId 待绑定的VM唯一标识
 * @param coreId 目标核编号（仅支持核2~N）
 * @return bool 申请成功返回true，失败返回false
 * @exception std::runtime_error 核编号非法、核已被占用、用户配额不足时抛出异常
 * @note 仅管理员和核心用户可调用该函数
 */
bool applyStaticCore(uint32_t vmId, uint32_t coreId) {
    // 函数逻辑
}
   
```

### 4.4 代码行注释

- 复杂逻辑、关键代码行（如指令执行、上下文保存、核锁操作），添加行注释，说明逻辑意图，避免他人误解。

- bug修复、临时修改的代码，添加行注释，说明修改原因、修改时间，便于后期迭代。

- 禁止对简单、直观的代码添加注释（如// 执行加法操作），避免冗余。

### 4.5 日志注释

日志输出需清晰、规范，包含时间、模块、日志级别、具体信息，便于调试与监控；日志级别分为DEBUG（调试）、INFO（信息）、ERROR（错误），根据场景合理选择。

示例：

```cpp

// DEBUG级日志：调试核锁申请过程
SPDLOG_DEBUG("Core lock apply: vmId={}, coreId={}, lockStatus={}", vmId, coreId, lockStatus);
// ERROR级日志：核编号非法异常
SPDLOG_ERROR("Core id invalid: coreId={}, valid range is 2~{}", coreId, CORE_MAX_LIMIT);
    
```

## 5. 代码格式规范

### 5.1 缩进与换行

- 缩进：统一使用4个空格缩进，禁止使用Tab缩进，确保不同编辑器下格式一致。

- 换行：每个函数独立换行；类/结构体的成员函数、成员变量，每个独立换行；逻辑块（if/else、for/while、switch）前后换行；复杂表达式按逻辑换行，便于阅读。

- 大括号：左大括号{紧跟语句后，不单独换行；右大括号}单独换行，与对应语句对齐；逻辑块内的代码缩进4个空格。

示例：

```cpp

if (coreId < 2 || coreId > CORE_MAX_LIMIT) {
    SPDLOG_ERROR("Core id invalid");
    throw std::runtime_error("Core id out of range");
}
for (uint32_t i = 2; i <= CORE_MAX_LIMIT; i++) {
    if (coreStatus[i] == CORE_STATUS_IDLE) {
        targetCoreId = i;
        break;
    }
}
    
```

### 5.2 空格与符号
- 代码统一使用tab作为缩见，代码撰写者应该保证撰写者写的所有字符为可见字符。

- 不允许在输出中使用表情包。

- 所有代码应保证使用'\n'换行。
